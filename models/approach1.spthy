// Approach 1: Start from @TheZ3ro's sequence diagram from Verifpal[1] and write
// a native Tamarin theory for it.
//
// [1]: https://github.com/freedomofpress/securedrop-poc/issues/16#issuecomment-1764436420

theory approach1
begin

builtins: asymmetric-encryption, diffie-hellman, symmetric-encryption

rule Jo_tx_enrollment:
    [
        Fr(~jc_priv),
        Fr(~je_priv)
    ]
    --[ Tx($Jo, 'enroll', $Jo) ]->
    [
        !Ltk($Jc, ~jc_priv), !Pk($Jc, 'g'^~jc_priv),
        !Ltk($Je, ~je_priv), !Pk($Je, 'g'^~je_priv),
        Out(<'enroll', 'g'^~jc_priv, 'g'^~je_priv>),
    ]

rule So_init:
    [
        Fr(~sc_priv),
        Fr(~se_priv),
    ]
    --[ ]->
    [
        !Ltk($Sc, ~sc_priv), !Pk($Sc, 'g'^~sc_priv),
        !Ltk($Se, ~se_priv), !Pk($Se, 'g'^~se_priv),
    ]

rule Se_rx_enrollment:
    [
        In(<'enroll', jc_pub, je_pub>),
    ]
    --[ Rx($Se, 'enroll', $Jo), Tx($Se, 'broadcast', $Jo) ]->
    [
        Out(<'broadcast', jc_pub, je_pub>)
    ]

rule So_rx_broadcast:
    [
        In(<'broadcast', jc_pub, je_pub>),
    ]
    --[ Rx($So, 'broadcast', $Jo) ]->
    [ StJoKeys($So, jc_pub, je_pub) ]

rule So_tx_message:
    let source_challenge1 = jc_pub^~me_priv1
        msg_encryption_key1 = je_pub^~me_priv1 in
    [
        Fr(~message1),
        Fr(~me_priv1),
        StJoKeys($So, jc_pub, je_pub),
    ]
    --[ Tx($So, 'msg', $msg) ]->
    [
        !Ltk($M, ~me_priv1), !Pk($M, 'g'^~me_priv1),
        Out(<'msg', 'g'^~me_priv1, source_challenge1, senc(~message1, msg_encryption_key1)>),
    ]

rule Se_rx_message:
    let server_attestation1 = me_pub1^~re_priv1
        server_shared1 = source_challenge1^~re_priv1 in
    [
        In(<'msg', me_pub1, source_challenge1, ciphertext1>),
        Fr(~re_priv1),
        Fr(~message_id),
    ]
    --[ Rx($Se, 'msg', $msg), Tx($Se, 'ch', $msg) ]->
    [
        StCiphertext(me_pub1, ciphertext1),
        Out(<'ch', server_attestation1, senc(~message_id, server_shared1)>),
    ]

rule Jo_rx_challenge:
    let recovered_shared1 = server_attestation1^~jc_priv in
    [
        In(<'ch', server_attestation1, ciphertext_id>),
        !Ltk($Jc, ~jc_priv),
    ]
    --[ Rx($Jo, 'ch', $msg), Tx($Jo, 'req', $msg) ]->
    [
        Out(<'req', sdec(ciphertext_id, recovered_shared1)>),
    ]

rule Se_rx_request:
    [
        In(<'req', decrypted_message_id>),
        StCiphertext(me_pub1, ciphertext1),
    ]
    --[ Rx($Se, 'req', $msg), Tx($Se, 'res', $msg) ]->
    [
        Out(<'res', me_pub1, ciphertext1>),
    ]

rule Jo_rx_response:
    let recovered_msg_encryption_key = me_pub1^~je_priv in
    [
        In(<'res', me_pub1, ciphertext1>),
        !Ltk($Je, ~je_priv),
    ]
    --[ Rx($Jo, 'res', $msg) ]->
    [
        StPlaintext(sdec(ciphertext1, recovered_msg_encryption_key)),
    ]

lemma journalist_enrollment:
  exists-trace
    "Ex Jo Se #i #j.
          Tx(Jo, 'enroll', Jo) @i &
          Rx(Se, 'enroll', Jo) @j
          "

lemma journalist_broadcast:
  exists-trace
    "Ex Jo Se So #i #j.
          Tx(Se, 'broadcast', Jo) @i &
          Rx(So, 'broadcast', Jo) @j
          "

lemma source_send:
    exists-trace
        "Ex Se So msg #i #j.
            Tx(So, 'msg', msg) @i &
            Rx(Se, 'msg', msg) @j
            "

lemma journalist_challenge:
    exists-trace
        "Ex Jo Se msg #i #j.
            Tx(Se, 'ch', msg) @i &
            Rx(Jo, 'ch', msg) @j
            "

lemma journalist_request:
    exists-trace
        "Ex Jo Se msg #i #j.
            Tx(Jo, 'req', msg) @i &
            Rx(Se, 'req', msg) @j
            "

lemma server_response:
    exists-trace
        "Ex Jo Se msg #i #j.
            Tx(Se, 'res', msg) @i &
            Rx(Jo, 'res', msg) @j
            "

// lemma executability:  message sent --> message received

// lemma success:  message encrypted --> message decrypted

end
