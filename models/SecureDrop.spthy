// Approach 1: Start from @TheZ3ro's sequence diagram from Verifpal[1] and write
// a native Tamarin theory for it.
//
// Approach 2: Start from message-retrieval, assuming the server and the sender
// are the same.  Then factor the server out as the intermediary.
// 
// [1]: https://github.com/freedomofpress/securedrop-poc/issues/16#issuecomment-1764436420

theory securedropng
begin

builtins: symmetric-encryption, diffie-hellman

rule Ltk:
    let pk = 'g'^~sk in  // per <https://tamarin-prover.com/manual/master/book/005_protocol-specification-rules.html#public-key-infrastructure>
    [ Fr(~sk) ]
    -->
    [ !Ltk($x, ~sk), !Pk($x, pk),  // s/$P/$x/, because not all of our public keys belong to participants
      Out(pk)
    ]


rule SourceSend:
    let encryption_shared_key1 = je_pub1^~me_priv1
        fetching_shared_key1 = jc_pub1^~me_priv1 in
    [
        !Ltk($ME1, ~me_priv1), // Per message ephemeral private key
        !Pk($ME1, me_pub1), // Per message ephemeral public key
        !Pk($JC1, jc_pub1), // Journalist fetching public key --> the key of the destination journalist
        !Pk($JE1, je_pub1), // Journalist ephemeral encryption public key -> recipient target encryption pubkey
        Fr(~secret_submission1)
    ]
    --[
        MessageWasSent(~secret_submission1, me_pub1, fetching_shared_key1)
    ]->
    // Submission is always a triplet, encrypts message, ephemeral msg pubkey and the partial DH
    // We also tag the packet to catch it afterwards
    [
        Out(<'submit', senc(~secret_submission1, encryption_shared_key1), me_pub1, fetching_shared_key1>)
    ]

rule ServerInit:  // This is both setup and sending.
    let server_shared1 = fetching_shared_key1^~re_priv1
        server_attestation1 = me_pub1^~re_priv1 in
    [
        !Ltk($RE1, ~re_priv1),
        Fr(~message_id1),
        In(<'submit', encrypted_message1, me_pub1, fetching_shared_key1>)
    ]
    --[ MessageIDWasCreated(~message_id1) ]->
    [ Out(<'have_id', senc(server_shared1, ~message_id1), server_attestation1> ), Eq('submit', submit_code) ]  // FIXME: this is a broadcast

rule ClientFetchID:
    let client_shared1 = server_attestation1^~jc_priv1 in
    [
      In(<'fetch', encrypted_message_id1, server_attestation1>), !Ltk($JC1, ~jc_priv1),
    ]
    --[ Eq(sdec(client_shared1, encrypted_message_id1), ~message_id1),
        ClientHasMessageID(~message_id1)
    ]->
    [ Out(<'fetch', ~message_id1>) ]

rule ServerReturn:
    [ In(<'fetch', ~message_id1>) ]
    -->
    [ Out(<'have_message', encrypted_message1>) ]

  rule ClientFetch:
    let encryption_shared_key1 = je_pub1^~me_priv1 in
    [ In(<'have_message', encrypted_message>) ]
    --[ Eq(sdec(encryption_shared_key1, ~secret_submission1)) ]->
    [ ]


// Generic question: how do we attempt proving indistinguishability? Is 2 message enough by induction?

lemma Executability:
  exists-trace
  "Ex m mepub mgdh #t. MessageWasSent(m, mepub, mgdh) @ #t & Ex mid #t. MessageIDWasCreated(mid) @ #t"

lemma SecrecyMessageID:
  "All m #t. MessageIDWasCreated(m) @ #t ==> not Ex #x. K(m) @ #x"
 
lemma SecrecyMessage: 
  "All m mepub mgdh #t. MessageWasSent(m, mepub, mgdh) @ #t ==> not Ex #x. K(m) @ x"

// restriction ...
restriction Eq:
  "All t1 t2 #x. Eq(t1, t2) @ #x ==> t1 = t2"

// lemma ...

end